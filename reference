Competitors:
Guncraft (XBLA people)
brickforce (korean)

perftools

Giving Player Feeling of Speed
increase FOV when boosting with jetpack
http://gamedev.stackexchange.com/questions/23461/giving-the-illusion-of-speed?newsletter=1&nlcode=38107|0f4c

The Laws of Online World Design
http://www.raphkoster.com/gaming/laws.shtml

Server Log Visualization:
http://code.google.com/p/logstalgia/

Remote Crash Reporting:
google-breakpad
http://code.google.com/p/google-breakpad/wiki/GettingStartedWithBreakpad

Sound:
http://www.soundsnap.com/

Repo Visualization:
http://code.google.com/p/gource/
sudo apt-get install gource

Minecraft GLSL
http://www.youtube.com/watch?feature=player_detailpage&v=C4XcJff2b_I
Tilt Shift Minecraft
http://imgur.com/a/Pm7Q4

Wang Tiles for Terrain/Dungeon Generation:

http://kagdev.tumblr.com/post/16119508016/wang-tiles
http://en.wikipedia.org/wiki/Wang_tiles
http://nothings.org/gamedev/herringbone/

Webdesign/layout
http://www.worldalpha.com/storyline

Bloom Shader and Gaussian Blur
http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/
http://prideout.net/archive/bloom/index.php

You could certainly bloom each level you downsample to...that's actually how Halo 3 does it. They downsample to a small size, blur, upscale, blur, upscale, blur once more, and then upscale and composite with the tone mapped source image. I find that approach to be a little overkill, so I just blur the lowest level about 4 times (4 vertical and 4 horizontal passes) instead. I would just experiment and see what works best for you.

!!! Minecraft: "implementing new features that will “reward exploration and combat more."
<-- inventives

cmmalloc - better than valgrind
tells you where mallocs are occuring and detects things that have not been freed
http://cs.ecs.baylor.edu/~donahoo/tools/ccmalloc/test1.log
http://cs.ecs.baylor.edu/~donahoo/tools/ccmalloc/

eNet Performance issues:
http://www.leadwerks.com/werkspace/blog/50/entry-248-enet-modifications/
preventing clients from crashing server
track memory allocation / malloc

gDEbugger is great for interrogating your data, catching OpenGL errors and working out where things are going wrong. 
GPUPerfStudio is much better for performance analysis. It will do a frame break down showing you the exact duration of all your API calls, which can be very enlightening. It will also show you the time taken for each stage in your render pipeline (i.e. each framebuffer switch or swap buffers operation), telling you how costly your post-processing is compared to your lighting stage, or whatever. 

Performance/profiling:  AMD CodeAnalyst

OpenGL Profiling:
NVidia's PerfHUD and GLExpert 

Bloom Filter:
http://en.wikipedia.org/wiki/Bloom_(shader_effect)

Motion Blur:
http://http.developer.nvidia.com/GPUGems3/gpugems3_ch27.html
http://gamedev.stackexchange.com/questions/8770/glsl-shader-effects-how-to-do-motion-blur-etc

Handling Mouse Movement:
http://gamedev.stackexchange.com/questions/1083/what-makes-aiming-in-a-console-first-person-shooter-feel-good

AoS Player Stats:
http://www.ace-spades.com/output.txt
http://www.ace-spades.com/stats.txt
http://staging.ace-spades.com
http://staging.ace-spades.com/serverlist.json

Implementing Jumping:
http://oos.moxiecode.com/tut_12/index.html

Splatter Textures:
http://en.wikipedia.org/wiki/Texture_splatting
<JoJoeStinky> might be useful for drawing pathways and roads through yyour terrain,
!!! For pathways and roads

Why Minecraft is Slow:
http://optifog.blogspot.com/
http://www.reddit.com/r/programming/comments/kgq62/understanding_minecraft_performance/

Character Dimensions and Boss Battle:
http://www.youtube.com/watch?v=6lA4ohHhCsw&feature=feedu

!!! OptiFine MT (multithreaded) tries to solve the problem by decoupling the chunk loading from the screen updates so that one complex chunk is distributed over several frames or several empty chunks are loaded inside one frame. The target is to stabilize the frame rate and speed up the loading of empty chunks.

Enabling SSE3 optimizations:
http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html
http://stackoverflow.com/questions/661338/sse-sse2-and-sse3-for-gnu-c
-mtune
-march

Ragdoll:

http://www.gamasutra.com/resource_guide/20030121/jacobson_01.shtml

Ambient Occultion:
!!! http://codeflow.org/entries/2010/dec/09/minecraft-like-rendering-experiments-in-opengl-4/#ambient-occlusion

Fast Inverse Square Root:
http://betterexplained.com/articles/understanding-quakes-fast-inverse-square-root/

float InvSqrt(float x){
   float xhalf = 0.5f * x;
   int i = *(int*)&#038;x; // store floating-point bits in integer
   i = 0x5f3759d5 - (i >> 1); // initial guess for Newton's method
   x = *(float*)&#038;i; // convert new bits into float
   x = x*(1.5f - xhalf*x*x); // One round of Newton's method
   return x;
}

Terrain Generation:
http://www.reddit.com/r/Minecraft/comments/g0my6/how_terrain_generation_works_in_minecraft/

!!! is down, try later
http://archive.gamedev.net/community/forums/mod/journal/journal.asp?jn=259175&cmonth=11&cyear=2010


Profiling Tool:
Need newer version of ubuntu
http://developer.amd.com/tools/CodeAnalyst/codeanalystlinux/Pages/default.aspx

Catching Memory Leaks:
 The Valgrind memcheck tool is a fantastic way to find all sorts of uninitialized variables and other memory bugs. Valgrind is limited because it is quite slow, it can only find bugs that still exist in the generated machine code (so it can't find things the optimizer removes),

efence - Electric Fence Malloc Debugger
http://linux.die.net/man/3/efence

Noise:

http://mines.lumpylumpy.com/Electronics/Computers/Software/Cpp/Graphics/Bitmap/Textures/Noise/Voronoi.php

Texture Generation:
http://lithosphere.codeflow.org/download.html


Occlusion Queries:

http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter06.html

Some games—for example, shader-heavy ones—use a separate initial rendering pass that writes only to the depth buffer. Subsequent passes test against this depth buffer, and thus expensive shading is done only for visible pixels. If the scenes are complex, our occlusion-culling algorithm can be used to accelerate establishing the initial depth buffer and at the same time to obtain a complete visibility classification of the hierarchy. For the subsequent passes, we skip over objects or whole groups of objects that are completely invisible at virtually no cost.

Minimizing polygon count by software backface culling:
sort polygons into lists based upon z level and faces
"the vertex processor has no information regarding connectivity, hence operations that require topological knowledge can’t be performed in here. For instance it is not possible for a vertex shader to perform back face culling, since it operates on vertices and not on faces. The vertex processor processes vertices individually and has no clue of the remaining vertices."
http://www.lighthouse3d.com/tutorials/glsl-tutorial/vertex-processor/

Array Textures:
http://www.opengl.org/wiki/Array_Texture

!!! Bitmap Fonts:
converts true type to bitmap
http://www.angelcode.com/products/bmfont/
http://ace-spades.com/wp-content/uploads/DDFontMake.exe
http://www.gamedev.net/topic/330742-quick-tutorial-variable-width-bitmap-fonts/

Automatic Mipmapp Generation
http://www.opengl.org/wiki/Common_Mistakes#Automatic_mipmap_generation

glGenerateMipmap(GL_TEXTURE_2D);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, pixels);
glGenerateMipmap(GL_TEXTURE_2D);  //Generate mipmaps now!!!

Charged Miners Shots:
http://miners.walkyrie.se/
http://miners.walkyrie.se/experiments.html

Sound Effects:
http://www.shockwave-sound.com/collections.html
http://www.sounddogs.com/

Design:
http://insertcredit.com/2011/09/22/who-killed-videogames-a-ghost-story/
design: http://www.gdcvault.com/play/1014982/Truth-in-Game
player types: http://www.gamasutra.com/view/feature/6474/personality_and_play_styles_a_.php

GlBlend Techno Particle Effects
http://www.ruudbijnen.nl/blog/2010/09/textures-and-opengl-blending/

Ways of Creating Textures:
	Much of the world texture detail in Team Fortress 2 comes from
hand-painted albedo textures which intentionally contain loose de-
tails with visible brush strokes that are intended to portray the tactile
quality of a given surface, as shown in Figure 5. In the early stages
of development, many of these 2D textures were physically painted
on canvas with watercolors and scanned to make texture maps. As
we refined the art style of the game, texture artists shifted to using
photorealistic reference images with a series of filters and digital
brush strokes applied to achieve the desired look of a physically
painted texture.
	Not only does this hand-painted source material create an illustra-
tive NPR style in rendered images, but we have found that these
abstract texture designs hold up under magnification better than
textures created from photo reference due to their more intentional
design and lack of photo artifacts. Furthermore, we believe that
high frequency geometric and texture detail found in photorealis-
tic games can often overpower the ability of designers to compose
game environments and emphasize gameplay features visually us-
ing intentional design choices such as changes in color value.

