APPNAME = 'dc_client'
VERSION = '0.1'

top = '.'
out = 'build'

import errno
import os
import os.path
import platform
import shutil
import subprocess
import re

MAIN_TEST_CODE = """
int main(int argc, char *argv[]) {
    return 0;
}
"""

_OS = None
os_libpth = ''

def _grab_output(*cmd):
    return subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0]


def get_version():
    try:
        OS = platform.system()
        if OS == 'Windows':
            version = subprocess.check_output(['/c/dc_mmo/get_current_head.sh'], shell=True)
        else:
            version = subprocess.check_output(['../get_current_head.sh'], shell=True)
        #//version = os.popen('../get_current_head.sh').read()
        print "version= %s" % (version)
    except Exception, e:
        print "Could not get version number from hg repo. Abort"
        print Exception, e
        raise Exception, e

    try:
        version = int(version.strip())
    except ValueError:
        print "Version %s invalid" % (version,)
        raise ValueError

    print "Gnomescroll Version: %d" % (version,)
    return version

def options(opt):
    opt.load('compiler_c compiler_cxx python cython')

def configure(conf, add_flags=[], rm_flags=[], sound='openal', centos=False):
    global _OS
    global os_libpth

    if centos:  #doesntwork
        conf.check_tool('gcc44')
        conf.check_tool('g++44')
    else:
        conf.check_tool('gcc')
        conf.check_tool('g++')
    conf.check_tool('python')
    conf.check_tool('cython')
    #conf.load('compiler_c compiler_cxx python cython')

    conf.check_python_version((2,6,0))
    conf.check_python_headers()

    conf.cc_add_flags()     #"-g" -ggdb
    conf.link_add_flags()   #"-g" -ggdb

    OS = platform.system()
    _OS = OS
    conf.env.os = OS
    
    '''
    add to linker for faster linking --incremental
    must be removed from production build
    '''
    
    '''
    Using -Winline will warn when a function marked inline could not be substituted, and will give the reason for the failure.
    '''

    '''
    GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the inline keyword. You can override this with -fno-default-inline
    '''

    if OS == 'Windows':
        cflags = ['-g', '-fpermissive', '-static-libgcc']
    else:
        cflags = ['-ggdb', '-fPIC'] # '-lefence'

    if OS == 'Windows':
        conf.env.append_value("LINKFLAGS", "-lwsock32")
        conf.env.append_value("LINKFLAGS", "-lws2_32")
        conf.env.append_value("LINKFLAGS", "-lwinmm")

    if OS == 'Linux':
        conf.env.append_value("LINKFLAGS", "-lrt") #64 bit support

    version = get_version()
    extra_options = ['-Wall', '-DDC_CLIENT=1', '-fno-exceptions', '-Winline', '-Wno-switch-enum', '-Wno-switch', '-DGNOMESCROLL_DSO_EXPORTS=1', '-DGNOMESCROLL_DSO=1', '-DDC_VERSION=%d' % (version,)] #'-fstrict-aliasing'
    cflags += extra_options

    if OS == 'Darwin':
        cflags += ['-s']

    cflags += [c for c in add_flags if c not in cflags]
    cflags = [c for c in cflags if c not in rm_flags]

    if sound.lower() == 'openal':
        cflags.append('-DUSE_OPENAL=1')
    elif sound.lower() == 'fmod':
        cflags.append('-DUSE_FMOD=1')

    conf.env.append_value('CFLAGS', cflags)
    conf.env.append_value('CXXFLAGS', cflags)
    

    '''
    incremental linking
    may reduce recompile time
    should not be used for release builds
    ''' 
    #conf.env.append_value("LINKFLAGS", "--incremental")

    conf.check(header_name='GL/glew.h', mandatory=True, includes='/usr/local/cuda/extras/CUPTI/include')

    if OS == 'Windows':
        glew_lib_path = ['/c/lib/glew/lib/', '/c/lib/glew/bin/']
        conf.check(lib=['opengl32', 'glu32', 'glew32'], libpath=glew_lib_path, uselib_store='GL') 
    elif OS == 'Linux':
        conf.check(lib=['GL',], uselib_store='GL')
        conf.check(lib=['GLU'], uselib_store='GL')
        conf.check(lib=['GLEW'], uselib_store='GL')
    elif OS == 'Darwin':
        conf.check(lib=['GLEW'], framework=['Cocoa', 'OpenGL'], uselib_store='GL')

    if OS != 'Windows':
        conf.check_cfg(path='sdl-config', args='--cflags --libs', package='', uselib_store='SDL')
    if OS == 'Windows':
        conf.check_cfg(path='bash.exe', args='/c/lib/SDL/bin/sdl-config --cflags --libs', package='', uselib_store='SDL')        

    conf.env.INCLUDES = []

    conf.check(header_name='SDL.h',
               use='SDL',
               fragment='#include <SDL.h>' + MAIN_TEST_CODE,
               mandatory=True)
    
    conf.check(header_name='SDL_image.h',
               lib='SDL_image',
               use='SDL',
               uselib_store='SDL_image',
               fragment='#include <SDL_image.h>' + MAIN_TEST_CODE,
               mandatory=True)

    if sound.lower() == 'openal':
        if OS == 'Darwin':
            conf.check(
                lib=[],
                framework=['OpenAL'],
                uselib_store='openal',
                mandatory=True
            )
        elif OS == 'Windows':
            conf.check(header_name='AL/al.h',
                       lib='OpenAL32',
                       use='openal',
                       uselib_store='openal',
                       fragment='#include <AL/al.h>\n#include <AL/alc.h>' + MAIN_TEST_CODE,
                       mandatory=True)
        else:
            conf.check(header_name='AL/al.h',
                       lib='openal',
                       use='openal',
                       uselib_store='openal',
                       fragment='#include <AL/al.h>\n#include <AL/alc.h>' + MAIN_TEST_CODE,
                       mandatory=True)

    '''
    conf.check(header_name='lua.h',
               lib='luajit-5.1', #'lua5.1',
               use='luajit-5.1', #'lua5.1',
               uselib_store='LUA',
               fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
               includes='/usr/include/luajit-2.0',
               mandatory=True)
    '''

    fmod_includes = []
    fmod_rpath = []
    if sound.lower() == 'fmod':
        incp='../../libraries/lin/fmod/inc'  #its in ./libraries/lin/fmod/inc
        libp='../../../libraries/lin/fmod/lib' #its in ./libraries/lin/fmod/lib

        if OS == 'Windows':
            os_libpth = './libraries/win'
            incp='../../libraries/win/fmod/inc'  #its in ./libraries/win/fmod/inc
            libp='../../../libraries/win/fmod/lib' #its in ./libraries/win/fmod/lib
        elif OS == 'Linux':
            os_libpth = './libraries/lin'
            incp='../../libraries/lin/fmod/inc'  #its in ./libraries/lin/fmod/inc
            libp='../../../libraries/lin/fmod/lib' #its in ./libraries/lin/fmod/lib
        elif OS == 'Darwin':
            os_libpth = './libraries/osx'
            incp='../../libraries/osx/fmod/inc'  #its in ./libraries/osx/fmod/inc
            libp='../../../libraries/osx/fmod/lib' #its in ./libraries/osx/fmod/lib

        conf.check(header_name='fmod.h', includes=[incp], mandatory=True)
        conf.check(lib=['fmodex'], libpath=[libp],includes=[incp], uselib_store='FMOD')

        fmod_includes = ['libraries/lin/fmod/inc']
        fmod_rpath = ['libraries/lin/fmod/lib', 'sound/api/lib/']
    
    #'cube_lib',
    conf.env.INCLUDES += ['./','c_lib', 'vox_lib', './net_lib'] + ['/usr/include'] + fmod_includes
    conf.env.RPATH = ['.', '..', './ext/', '\$ORIGIN/../lib', '\$ORIGIN/../lib', '/lib', '/usr/lib', '/usr/local/lib'] + fmod_rpath
    
def build(bld):
    OS = platform.system()

    using_fmod = using_openal = False
    if '-DUSE_FMOD=1' in bld.env.CFLAGS:
        using_fmod = True
    elif '-DUSE_OPENAL=1' in bld.env.CFLAGS:
        using_openal = True

    if using_fmod:
        """"""
        # FMOD hack
        if OS == 'Windows':
            os_libpth = './libraries/win'
        elif OS == 'Linux':
            os_libpth = './libraries/lin'
        elif OS == 'Darwin':
            os_libpth = './libraries/osx'

        print os.path.abspath(os.curdir)
        libpth = '%s/fmod/lib/' % (os_libpth,)
        despth = './build/sound/api/lib/'

        if os.path.exists(despth):
            for fn in os.listdir(despth):
                os.remove(despth + fn)
            for fn in os.listdir(libpth):
                shutil.copy2(libpth + fn, despth + fn)
        else:
            try:
                shutil.copytree(libpth, despth, symlinks=True)
            except IOError, e:
                pass
        """"""

    sound_framework = []
    sound_libraries = []
    common_libraries = []
    
    #lua_libraries = ['lua5.1'] #['luajit51'] #['lua50']
    lua_libraries = []

    SDL_libraries = ['GL', 'SDL', 'SDL_image']
    if using_fmod:
        sound_libraries = ['fmodex']
    elif using_openal:
        if OS == 'Darwin':
            #sound_libraries = ['OpenAL']
            sound_framework = ['OpenAL']
        elif OS == 'Windows':
            sound_libraries = ['OpenAL32']
        else:
            sound_libraries = ['openal']
    #noise_libraries = ['noise']

    if OS == "Darwin":
        png_libs=[]
    else:
        png_libs=['png']

    time_lib = ['rt']
    if OS == "Darwin":
        time_lib = []


    bld.env.CFLAGS.append('-fvisibility=hidden')    #hide most dso symbols for libc_lib
    c_lib_includes = []
    c_lib_libpath = []
    if using_fmod:
        c_lib_includes += ['./sound/api/inc/', './sound']
        c_lib_libpath += ['./sound/api/lib/']+['../sound/api/lib/','../../sound/api/lib/'] # hack
    #clib
    bld(features='cxx cxxshlib',
        source=['c_lib/c_lib.cpp'],
        use=common_libraries+time_lib+SDL_libraries+['LUA'], # +noise_libraries +png_libs
        lib=sound_libraries+png_libs,
        includes= c_lib_includes,
        libpath= c_lib_libpath,
        framework = sound_framework,
        target='c_lib')
    bld.env.CFLAGS.remove('-fvisibility=hidden')

    bld(features='cxx cshlib cxxshlib pyext',
        source=['c_lib/init_c_lib.pyx'],
        use=common_libraries + ['c_lib'],
        target='init_c_lib')

    # final
    bld(features='cxx cprogram pyembed',
        use=['c_lib'],
        source='run.c',
        target='run')

    # compile python files
    if '-DPRODUCTION=1' in bld.env.CFLAGS:
        import py_compile
        py_compile.compile('cube_dat.py')
        py_compile.compile('dat_loader.py')
        py_compile.compile('args_client.py')
        py_compile.compile('gameloop.py')
        py_compile.compile('opts.py')
        py_compile.compile('default_settings.py')
        
    bld.add_post_fun(install_in_ext)
    if '-DPRODUCTION=1' in bld.env.CFLAGS:
        bld.add_post_fun(strip_symbols)

def strip_symbols(ctx):
    OS = platform.system()
    if OS == 'Linux':
        print 'Stripping symbols'
        subprocess.Popen(['strip', '-s', 'libc_lib.so'])
        subprocess.Popen(['strip', '-s', 'libfont_lib.so'])
        subprocess.Popen(['strip', '-s', 'build/init_c_lib.so'])
        subprocess.Popen(['strip', '-s', 'ext/init_c_lib.so'])

def install_in_ext(ctx):
    global out, _OS

    # Hax to install files into ./ext/, after build

    try:
        run_target = ctx.env.cprogram_PATTERN % 'run'
        shutil.copy2(os.path.join(out, run_target), './' + run_target)
    except:
        pass


    try:
        c_lib_target = ctx.env.cshlib_PATTERN % 'c_lib'
        shutil.copy2(os.path.join(out, c_lib_target), './' + c_lib_target)
    except:
        pass
        #print "Error1: cannot copy %s to %s" % (c_lib_target, os.path.join(out, c_lib_target))

    targets = [
       'init_c_lib',
    ]

    for target in targets:
        dest_path = target.replace('.', '/')
        dest_path = './ext/' + ctx.env.pyext_PATTERN % dest_path
        ensure_dir(os.path.dirname(dest_path))
        try:
            if 'csound' in target:
                target = target.replace('csound', 'libcsound')
                dest_path = dest_path.replace('csound', 'libcsound')
            shutil.copy2(os.path.join(out, ctx.env.pyext_PATTERN % target), dest_path)
        except Exception, e:
            pass
            #print e
            #print "Error: cannot copy %s to %s" % (os.path.join(out, ctx.env.pyext_PATTERN % target), dest_path)
    make_dest_modules(ctx)

    if '-DUSE_FMOD=1' in ctx.env.CFLAGS:
        install_fmod_libs()

def ensure_dir(path):
    try:
        os.makedirs(path)
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise

def install_fmod_libs():
    global _OS
    if _OS == 'Darwin':
        libfmodex_name = "libfmodex.dylib"
        libfmodex_pth = "./libraries/osx/fmod/lib/%s" % (libfmodex_name,)
        if not os.path.exists(libfmodex_name):
            if not os.path.exists(libfmodex_pth):
                print "WARNING: OSX Build problem -- Missing %s" % (libfmodex_pth,)
            else:
                try:
                    shutil.copy2(libfmdex_pth, libfmodex_name)
                except:
                    print "Failed to copy %s to %s" % (libfmodex_pth, libfmodex_name,)

def make_dest_modules(ctx):
    for root, dirs, files in os.walk('./ext/'):
        with open(os.path.join(root, '__init__.py'), 'wb') as f:
            f.close()


'''
Subclass related *Context
e.g. ConfigurationContext, BuildContext
cmd,fun = 'name_of_function'
'''
from waflib.Configure import ConfigurationContext
class optimized_ctx(ConfigurationContext):
    cmd = 'optimized'
    fun = 'optimized'

from waflib.Configure import ConfigurationContext
class optimized_ctx(ConfigurationContext):
    cmd = 'optimized2'
    fun = 'optimized2'

class optimized_ctx(ConfigurationContext):
    cmd = 'debug'
    fun = 'debug'

class lint_ctx(ConfigurationContext):
    cmd = 'lint'
    fun = 'lint'

class profile_ctx(ConfigurationContext):
    cmd = 'profile'
    fun = 'profile'
    
class exceptions_ctx(ConfigurationContext):
    cmd = 'exceptions'
    fun = 'exceptions'

class production_ctx(ConfigurationContext):
    cmd = 'production'
    fun = 'production'
    
class production_dev_ctx(ConfigurationContext):
    cmd = 'production_dev'
    fun = 'production_dev'
    
class linux_production_ctx(ConfigurationContext):
    cmd = 'linux'
    fun = 'linux'

class linux64_production_ctx(ConfigurationContext):
    cmd = 'linux64'
    fun = 'linux64'
    
class centos64_production_ctx(ConfigurationContext):
    cmd = 'centos64'
    fun = 'centos64'

class fmod_ctx(ConfigurationContext):
    cmd = 'fmod'
    fun = 'fmod'

class extra_ctx(ConfigurationContext):
    cmd = 'extra'
    fun = 'extra'

def extra(ctx):
    configure(ctx, add_flags=['-Wextra'])

def fmod(ctx):
    configure(ctx, sound='fmod')
    
class openal_ctx(ConfigurationContext):
    cmd = 'openal'
    fun = 'openal'

def openal(ctx):
    configure(ctx, sound='openal')
    
#class bounds_check_ctx(ConfigurationContext):
    #cmd = 'bounds_check'
    #fun = 'bounds_check'

#def bounds_check(ctx):
    #configure(ctx)
    #ctx.env.CFLAGS.append('-fbounds-checking')
    #ctx.env.CXXFLAGS.append('-fbounds-checking')

def linux(ctx):
    production(ctx, add=['-shared-libgcc'])

def linux64(ctx):
    production(ctx, add=['-m64', '-shared-libgcc'])
    
def centos64(ctx):
    production(ctx, add=['-m64', '-shared-libgcc'], centos=True)
    
def production(ctx, add=[], rm=[], centos=False):
    configure(ctx, add_flags=add+['-DPRODUCTION=1', '-O3', '-Winline', '-O3'], rm_flags=rm+['-ggdb', '-g'], centos=centos)

# developers' build of the production build
def production_dev(ctx, add=[], rm=[], centos=False):
    configure(ctx, add_flags=add+['-DPRODUCTION=1', '-DPRODUCTION_DEV=1', '-O3', '-Winline', '-O3'], rm_flags=rm+['-ggdb', '-g'], centos=centos)

def profile(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-O3')
    ctx.env.CXXFLAGS.append('-O3')
    ctx.env.CFLAGS.append('-pg')
    ctx.env.CXXFLAGS.append('-pg')
    ctx.env.append_value("LINKFLAGS", "-pg")

def optimized(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-O3')
    ctx.env.CXXFLAGS.append('-O3')
    #ctx.env.CXXFLAGS.append('-mtune=native')
    #ctx.env.CXXFLAGS.append('-march=native')

#run time profile optimization
def optimized2(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-O3')
    ctx.env.CXXFLAGS.append('-O3')
    ctx.env.CXXFLAGS.append('-Winline')
    #ctx.env.CFLAGS.append('-fprofile-generate')
    #ctx.env.CXXFLAGS.append('-fprofile-generate')

def debug(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-fstack-protector-all')
    ctx.env.CXXFLAGS.append('-fstack-protector-all')

def exceptions(ctx):
    configure(ctx)
    ctx.env.CFLAGS.remove('-fno-exceptions')
    ctx.env.CXXFLAGS.remove('-fno-exceptions')
    #ctx.check(header_name='libnoise/noise.h',
                #lib="noise",
               ##use='libnoise',
               #includes=['/usr/include'],
               #fragment='#include <libnoise/noise.h>',
               #mandatory=True)
               
# dont use this. it was an attempt to use GCC flags to lint the C/C++ code
# just throws a shit ton of errors starting from the SDL libraries
def lint(ctx):
    configure(ctx)
    lint_flags = [
        '-ansi',
        '-fno-common',
        '-fshort-enums',
        '-pedantic',
        '-undef',
        '-W',
        '-Waggregate-return',
        '-Wall',
        '-Wcast-align',
        '-Wcast-qual',
        '-Wconversion',
        '-Wmissing-declarations',
        '-Wredundant-decls',
        '-Wmissing-prototypes',
        '-Wnested-externs',
        '-Wpointer-arith',
        '-Wshadow',
        '-Wstrict-prototypes',
         #'-Wtraditional',
        '-Wwrite-strings',
    ]
    ctx.env.CFLAGS += lint_flags
    ctx.env.CXXFLAGS += lint_flags
