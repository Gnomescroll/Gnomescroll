APPNAME = 'gs_client'
VERSION = None

top = '.'

import os
import platform
import shutil
import subprocess
import shlex
from waflib import Errors
from waflib import Tools

Tools.c_preproc.go_absolute = True

MAIN_TEST_CODE = '''
int main(int argc, char *argv[]) {
    return 0;
}
'''


'''
How do I build static C binaries?
For gcc, set conf.env.SHLIB_MARKER = '-Wl,-Bstatic' to link all
libraries in static mode, and add '-static' to the linkflags
to make a fully static binary.
'''


def _grab_output(*cmd):
    return subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0]


def get_version():
    with open('../src/c_lib/common/version.h') as f:
        r = f.readlines()
        r = [line.strip() for line in r if 'GS_VERSION' in line]
        assert len(r) == 1
        r = r[0]
        pieces = r.split(' ')
        assert len(pieces) == 3
        version = int(pieces[-1])
        return version

VERSION = str(get_version())


def options(opt):
    opt.load('compiler_c compiler_cxx')


def check_clang(conf, requested=False):
    OS = platform.system()
    if OS != 'Linux':
        return False

    # use clang if requested or available
    # If you do check_tool('g++') after this, it won't compile, even though
    # the check works
    use_clang = requested or bool(os.environ.get('WAF_USE_CLANG'))
    has_clang = False
    with open(os.devnull, 'w') as fnull:
        has_clang = (subprocess.call(shlex.split('which clang'), stdout=fnull,
                                     stderr=fnull) == 0)
    if use_clang and not has_clang:
        msg = 'ERROR: Clang requested, but not found on system'
        raise Errors.ConfigurationError(msg)
    return use_clang


def configure(conf, add_flags=[], rm_flags=[], link_flags=[], optlevel=0,
              production=False, awesomium=True, awesomium_debug=False,
              assimp=True, use_clang=False, auth=False):
    OS = platform.system()
    conf.env.os = OS

    arch = platform.architecture()[0]
    i386 = (arch == '32bit')
    x86_64 = (arch == '64bit')

    # Disable awesomium until it is completely removed
    awesomium = False

    optflag = '-O{0}'.format(optlevel)
    awe_stem = 'release'
    if awesomium_debug:
        awe_stem = 'debug'
    prodflag = '-DPRODUCTION={0}'.format(int(production))
    if production:
        awesomium = True
        assimp = True
        auth = True
        # Force 32-bit compilation in production
        i386 = True
        x86_64 = False
    if auth:
        awesomium = True
    aweflag = '-DGS_AWESOMIUM={0}'.format(int(awesomium))
    assimpflag = '-DGS_ASSIMP={0}'.format(int(assimp))
    authflag = '-DGS_AUTH={0}'.format(int(auth))

    assert i386 != x86_64
    conf.env.i386 = i386
    conf.env.x86_64 = x86_64

    arch_label = '32'
    if x86_64:
        arch_label = '64'

    use_clang = check_clang(conf, requested=use_clang)
    if use_clang:
        conf.check_tool('clang++')
    else:
        conf.check_tool('g++')

    '''
    add to linker for faster linking --incremental
    must be removed from production build
    '''

    '''
    Using -Winline will warn when a function marked inline could not be
    substituted, and will give the reason for the failure.
    '''

    '''
    GCC considers member functions defined within the body of a class to be
    marked inline even if they are not explicitly declared with the inline
    keyword. You can override this with -fno-default-inline
    '''

    #-ftime-report

    if OS == 'Windows':
        cxxflags = ['-fpermissive']  # '-g',
        # '-static', '-static-libgcc', '-static-libstdc++',
        cxxflags += ['-DNOMINMAX']  # disable min/max macros
        # disable '#define interface _COM_interface'
        # in windows header basetyps.h
        # cxxflags += ['-D__OBJC__']
        # cxxflags += ['-D_OBJC_NO_COM_']  # disable '#define interface
        # _COM_interface' in windows header basetyps.h
    else:
        cxxflags = ['-ggdb', '-fPIC']  # '-lefence'
        if i386:
            cxxflags.append('-m32')
            link_flags.append('-m32')

    # -fPIC may hurt optimization
    # '-Wl', '--export-dynamic'  to export symbols from exe to shared libaries
    if OS == 'Windows':
        conf.env.append_value('LINKFLAGS', '-lmingw32')
        conf.env.append_value('LINKFLAGS', '-lwsock32')
        conf.env.append_value('LINKFLAGS', '-lws2_32')
        conf.env.append_value('LINKFLAGS', '-lwinmm')

    if OS == 'Linux':
        conf.env.append_value('LINKFLAGS', '-lrt')  # 64 bit support
        # conf.env.append_value('LINKFLAGS', '-static') # static lib
        # conf.env.SHLIB_MARKER = '-Wl,-Bstatic'  # static lib
    if OS != 'Windows':
        conf.env.append_value('LINKFLAGS', '-rdynamic')  # 64 bit support

    warning_sound_flag = '-DENABLE_WARNING_SOUND=1'
    if production or OS != 'Windows':
        warning_sound_flag = '-DENABLE_WARNING_SOUND=0'

    extra_options = [
        '-Wall',
        '-Wempty-body',
        '-DDC_CLIENT=1',
        '-fno-exceptions',
        '-Wvla',  # warns variable array
        '-DGNOMESCROLL_DSO_EXPORTS=1',
        '-DGNOMESCROLL_DSO=1',
        aweflag,
        assimpflag,
        prodflag,
        warning_sound_flag,
        optflag,
        authflag,
        #'-fstrict-aliasing'
        #'-fno-default-inline'
    ]

    if use_clang:
        extra_options.append('-ferror-limit=0')

    if production:
        extra_options.append('-Wno-inline')
    else:
        extra_options.append('-Winline')

    cxxflags += extra_options

    if OS == 'Darwin':
        cxxflags += ['-s']

    cxxflags += [c for c in add_flags if c not in cxxflags]
    cxxflags = [c for c in cxxflags if c not in rm_flags]

    conf.env.append_value('CXXFLAGS', cxxflags)
    conf.env.append_value('LINKFLAGS', ' '.join(link_flags))

    '''
    incremental linking may reduce recompile time should not be used for
    release builds
    #conf.env.append_value('LINKFLAGS', '--incremental')
    '''
    # glew_inc_path = ['/usr/local/cuda/extras/CUPTI/include']
    glew_inc_path = ['../../../lib/win32/glew']
    conf.check(header_name='GL/glew.h', mandatory=True, includes=glew_inc_path)

    libpath = os.path.abspath('../lib/')
    if OS == 'Windows':
        print 'Current directory:', os.path.abspath(os.curdir)
        libpath = os.path.join(libpath, 'win32')
    else:
        if i386:
            libpath = os.path.join(libpath, 'lin32')
        elif x86_64:
            libpath = os.path.join(libpath, 'lin64')
        else:
            assert False  # should be either of the previous two

    if OS == 'Windows':
        # glew_lib_path = ['/c/lib/glew/lib/', '/c/lib/glew/bin/']
        glew_lib_path = [os.path.join(libpath, 'lib')]
        conf.check(lib=['opengl32'], uselib_store='GL')
        conf.check(lib=['glu32'], uselib_store='GL')
        conf.check(lib=['glew32'], libpath=glew_lib_path, uselib_store='GL')
    elif OS == 'Linux':
        conf.check(lib=['GL'], libpath=libpath, uselib_store='GL')
        conf.check(lib=['GLU'], libpath=libpath, uselib_store='GL')
        conf.check(lib=['GLEW'], libpath=libpath, uselib_store='GL')
    elif OS == 'Darwin':
        conf.check(lib=['GLEW'], framework=['Cocoa', 'OpenGL'],
                   uselib_store='GL')

    if OS == 'Linux':
        sdl_flags = ('-I../../lib/lin/include/SDL -D_GNU_SOURCE=1 -lSDL '
                     '-I../../lib/lin/include/SDL_image '
                     '-L../../../lib/lin{0}').format(arch_label)
        conf.check_cfg(path='echo', args=sdl_flags, package='',
                       uselib_store='SDL')
    elif OS == 'Windows':
        sdl_config_path = os.path.join(libpath, 'SDL/bin/sdl-config')
        sdl_inc_path = libpath
        sdl_lib_path = libpath
        sdl_config_cmd = '{0} --prefix={1} --exec-prefix={2} --cflags --libs'
        sdl_config_cmd = sdl_config_cmd.format(sdl_config_path, sdl_inc_path,
                                               sdl_lib_path)
        # subprocess.call('bash.exe ' + sdl_config_cmd, shell=True)
        conf.check_cfg(path='bash.exe',
                       args=sdl_config_cmd,
                       package='', uselib_store='SDL')
    else:
        conf.check_cfg(path='sdl-config', args='--cflags --libs',
                       package='', uselib_store='SDL')

    conf.env.INCLUDES = []

    conf.check(header_name='SDL.h',
               use='SDL',
               fragment='#include <SDL.h>' + MAIN_TEST_CODE,
               mandatory=True)

    conf.check(header_name='SDL_image.h',
               lib='SDL_image',
               use='SDL',
               uselib_store='SDL_image',
               fragment='#include <SDL_image.h>' + MAIN_TEST_CODE,
               mandatory=True)

    if OS == 'Darwin':
        conf.check(lib=[],
                   framework=['OpenAL'],
                   uselib_store='openal',
                   mandatory=True)
    elif OS == 'Windows':
        conf.check(header_name='AL/al.h',
                   lib='OpenAL32',
                   use='openal',
                   uselib_store='openal',
                   includes=[os.path.join(libpath, 'openal'), ],
                   libpath=[os.path.join(libpath, 'lib'), ],
                   fragment='#include <AL/al.h>\n#include <AL/alc.h>' +
                       MAIN_TEST_CODE,
                   mandatory=True)
    else:
        conf.check(header_name='AL/al.h',
                   lib='openal',
                   use='openal',
                   uselib_store='openal',
                   fragment='#include <AL/al.h>\n#include <AL/alc.h>' +
                       MAIN_TEST_CODE,
                   mandatory=True)

    if OS == 'Windows':
        lua_inc_path = os.path.join(libpath, 'LuaJIT-2.0.0-beta10')
        lua_lib_path = [os.path.join(libpath, 'lib')]
    else:
        lua_lib_path = ['/usr/local/lib', '/usr/local/lib32']
        lua_inc_path = ['/usr/include/luajit-2.0',
                        '/usr/local/include/luajit-2.0']

    if OS == 'Windows':
        conf.check(header_name='lua.hpp',
                   lib='lua51',
                   use='lua51',
                   libpath=lua_inc_path,
                   includes=lua_lib_path,
                   uselib_store='LUA',
                   fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
                   mandatory=True)
    elif OS == 'Linux':
        conf.check(header_name='lua.h',
                   lib='luajit-5.1',
                   use='luajit-5.1',
                   libpath=lua_lib_path,
                   includes=lua_inc_path,
                   uselib_store='LUA',
                   fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
                   mandatory=True)
    elif OS == 'Darwin':
        conf.check(header_name='lua.h',
                   lib='luajit-5.1',
                   use='luajit-5.1',
                   libpath=lua_lib_path,
                   includes=lua_inc_path,
                   uselib_store='LUA',
                   fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
                   mandatory=True)

    if awesomium:
        if OS == 'Windows':
            awesomium_lib_path = '../lib/win32/awesomium/lib/{0}/'
            awesomium_lib_path = awesomium_lib_path.format(awe_stem)
            awesomium_include_path = '../lib/win32/awesomium/include/'
            awesomium_name = 'Awesomium'
            if awesomium_debug:
                awesomium_name += '_d'
        elif OS == 'Linux':
            awesomium_lib_path = '../lib/lin32/awesomium/release/'
            awesomium_include_path = '../lib/lin32/awesomium/include/'
            awesomium_name = 'awesomium-1.6.5'
        else:
            assert False

        conf.check(lib=[awesomium_name],
                   use=awesomium_name,
                   includes=map(os.path.abspath, [awesomium_include_path]),
                   libpath=map(os.path.abspath, [awesomium_lib_path]),
                   uselib_store='AWESOMIUM')

    if assimp:
        if OS == 'Linux':
            assimp_lib = 'assimp'
            assimp_lib_path = [libpath]
            assimp_inc_path = ['../lib/lin/include/assimp/']
        elif OS == 'Windows':
            assimp_lib = 'Assimp32'
            assimp_lib_path = ['../lib/win32/lib/', '../lib/win32/dll/']
            assimp_inc_path = ['../lib/win32/assimp/']
        else:
            assert False

        conf.check(lib=assimp_lib,
                   use='assimp',
                   libpath=map(os.path.abspath, assimp_lib_path),
                   includes=map(os.path.abspath, assimp_inc_path),
                   uselib_store='ASSIMP')

    conf.env.INCLUDES += ['../src/c_lib', '../src', '../src/net_lib',
                          '/usr/include']
    if awesomium:
        if OS == 'Linux':
            conf.env.INCLUDES += ['../lib/lin32/awesomium/include/']
        elif OS == 'Windows':
            conf.env.INCLUDES += ['../lib/win32/awesomium/include/']
        else:
            assert False

    conf.env.RPATH = ['.', '..', '/lib', '/usr/lib', '/usr/local/lib']
    if OS == 'Windows':
        conf.env.INCLUDES.append('../lib/win32/')
        conf.env.RPATH.append('$ORIGIN/./lib')
        conf.env.RPATH.append('./lib')
        if awesomium:
            rpath = '$ORIGIN/./lib/win32/awesomium/lib/{0}'.format(awe_stem)
            conf.env.RPATH += [rpath]

    if OS == 'Linux':
        if production:
            lib_base_path = '$ORIGIN/./lib/lin{0}/'
        else:
            lib_base_path = '$ORIGIN/../lib/lin{0}/'
        conf.env.RPATH += [lib_base_path.format(arch_label)]
        if awesomium:
            conf.env.RPATH += [os.path.join(lib_base_path,
                                            'awesomium/release')]

    conf.env.assimp = assimp
    conf.env.awesomium = awesomium
    conf.env.awe_stem = awe_stem
    conf.env.production = production
    conf.env.build_modules = False


def build(bld):
    if bld.env.build_modules:
        bld.build_modules()
        return

    OS = platform.system()

    sound_framework = []
    sound_libraries = []
    debug_libs = []

    # debug_libs.append('efence')

    # lua_libraries = ['lua5.1'] #['luajit51'] #['lua50']
    # lua_libraries = ['luajit51']

    SDL_libraries = ['GL', 'SDL', 'SDL_image']

    if OS == 'Windows':
        sound_libraries = ['OpenAL32']
    else:
        sound_libraries = ['openal']

    png_libs = ['png']
    time_lib = ['rt']

    includes = []
    libs = []
    if OS == 'Windows':
        libpath = os.path.abspath('../lib/win32')
        includes = [os.path.join(libpath, path)
                    for path in os.listdir(libpath)]
        libs = ['lib', 'dll', 'awesomium/lib/{0}'.format(bld.env.awe_stem),
                'awesomium/bin/{0}'.format(bld.env.awe_stem)]
        libs = map(lambda x: os.path.join(libpath, x), libs)
    elif OS == 'Linux':
        includes.append(os.path.abspath('../lib/lin/include'))

    # bld.env.CXXFLAGS.append('-fvisibility=hidden')    #hide most dso symbols
    # for libc_lib
    use = time_lib + SDL_libraries + ['LUA']
    if bld.env.awesomium:
        use.append('AWESOMIUM')
    if bld.env.assimp:
        use.append('ASSIMP')

    target = 'run'
    bld(
        features='cxx cxxprogram',
        source=['../src/client/_client.cpp'],
        use=use,
        lib=sound_libraries + png_libs + debug_libs,
        includes=includes,
        libpath=libs,
        framework=sound_framework,
        # linkflags = ['-rdynamic'],
        target=target
    )
    # bld.env.CXXFLAGS.remove('-fvisibility=hidden')

    bld.add_post_fun(install_bin(target, 'build', '.'))

    # if ('-DPRODUCTION=1' in bld.env.CXXFLAGS and
    #     '-DNOSTRIPSYMBOLS' not in bld.env.CXXFLAGS):
    #    bld.add_post_fun(strip_symbols)


def build_modules(bld):
    includes = []
    libs = []

    target = 'test_module'
    bld(
        features='cxx cxxshlib',
        source=['../src/c_lib/camera/intro/_include.cpp'],
        #use=use,
        #lib=sound_libraries + png_libs + debug_libs,
        includes=includes,
        libpath=libs,
        #framework=sound_framework,
        # linkflags = ['-rdynamic'],
        target=target
    )

    target = 'lib{0}.so'.format(target)
    bld.add_post_fun(install_bin(target, 'build', '.plugins'))


def copy_awesomium_dlls(ctx):
    awe_dll_path = '../lib/win32/awesomium/bin/{0}/'
    awe_dll_path = awe_dll_path.format(ctx.env.awe_stem)
    for f in os.listdir(awe_dll_path):
        if f == 'locales':
            _path = os.path.join(awe_dll_path, f)
            for loc in os.listdir(_path):
                shutil.copy2(os.path.join(_path, loc),
                             os.path.join('./{0}'.format(f), loc))
        else:
            shutil.copy2(os.path.join(awe_dll_path, f),
                         os.path.join('./', f))


def install_bin(target, srcdir, outdir, dest_target=None):
    OS = platform.system()
    if dest_target is None:
        dest_target = target
    if OS == 'Windows':
        target += '.exe'
        dest_target += '.exe'

    def _install_bin(ctx):
        if not os.path.exists(outdir):
            os.makedirs(outdir)
        try:
            src = os.path.join(srcdir, target)
            dest = os.path.join(outdir, dest_target)
            if (os.path.exists(src) and
                    os.path.abspath(src) != os.path.abspath(dest)):
                shutil.copy2(src, dest)
                print 'Copied {0} to {1}'.format(src, dest)
        except Exception as e:
            msg = 'Failed to copy {0} to {1}. Reason: {2}'
            print msg.format(src, dest, str(e))

        try:
            # copy dlls into directory,
            # so Cell can run the exe from the folder.
            if OS == 'Windows':
                dll_path = '../lib/win32/dll/'
                dlls = os.listdir(dll_path)
                dlls = [dll for dll in dlls if dll.endswith('dll')]
                for dll in dlls:
                    src_dll = os.path.join(dll_path, dll)
                    dst_dll = os.path.join('./', dll)
                    shutil.copy2(src_dll, dst_dll)
                copy_awesomium_dlls(ctx)
                print 'Copied dlls to current directory'
        except Exception as e:
            msg = ('Error copying dlls from {0} to current directory. '
                   'Reason: {1}')
            print msg.format(dll_path, str(e))

    return _install_bin


from waflib.Build import BuildContext


BuildContext.build_modules = build_modules

from waflib.Configure import ConfigurationContext


class optimized_ctx(ConfigurationContext):
    cmd = 'optimized'
    fun = 'optimized'

from waflib.Configure import ConfigurationContext


class build_modules_ctx(ConfigurationContext):
    cmd = 'modules'
    fun = 'modules'


class optimized2_ctx(ConfigurationContext):
    cmd = 'optimized2'
    fun = 'optimized2'


class debug_ctx(ConfigurationContext):
    cmd = 'debug'
    fun = 'debug'


class lint_ctx(ConfigurationContext):
    cmd = 'lint'
    fun = 'lint'


class profile_ctx(ConfigurationContext):
    cmd = 'profile'
    fun = 'profile'


class profile_opt_ctx(ConfigurationContext):
    cmd = 'profile_opt'
    fun = 'profile_opt'


class exceptions_ctx(ConfigurationContext):
    cmd = 'exceptions'
    fun = 'exceptions'


class production_ctx(ConfigurationContext):
    cmd = 'production'
    fun = 'production'


class production_dev_ctx(ConfigurationContext):
    cmd = 'production_dev'
    fun = 'production_dev'


class linux_production_ctx(ConfigurationContext):
    cmd = 'linux'
    fun = 'linux'


class linux64_production_ctx(ConfigurationContext):
    cmd = 'linux64'
    fun = 'linux64'


class efence_ctx(ConfigurationContext):
    cmd = 'efence'
    fun = 'efence'


def modules(ctx):
    configure(ctx)
    ctx.env.build_modules = True


def efence(ctx):
    configure(ctx, add_flags=['-lefence'])


def linux(ctx):
    production(ctx, add=['-shared-libgcc'])


def linux64(ctx):
    production(ctx, add=['-m64', '-shared-libgcc'])


def production(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add + ['-DNDEBUG', '-Winline'], optlevel=3,
              rm_flags=rm + ['-ggdb', '-g'], production=True, use_clang=False)

# developers' build of the production build


def production_dev(ctx, add=[], rm=[]):
    configure(
        ctx, add_flags=add + ['-DPRODUCTION_DEV=1', '-Winline'], optlevel=3,
        rm_flags=rm + ['-ggdb', '-g'], production=True, use_clang=False)


def profile(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-pg')
    ctx.env.CXXFLAGS.append('-pg')
    ctx.env.append_value('LINKFLAGS', '-pg')


def profile_opt(ctx):
    configure(ctx, optlevel=3)
    ctx.env.CFLAGS.append('-pg')
    ctx.env.CXXFLAGS.append('-pg')
    ctx.env.append_value('LINKFLAGS', '-pg')


def optimized(ctx):
    configure(ctx, optlevel=3)
    # ctx.env.CXXFLAGS.append('-mtune=native')
    # ctx.env.CXXFLAGS.append('-march=native')

# run time profile optimization


def optimized2(ctx):
    configure(ctx, optlevel=3)
    ctx.env.CXXFLAGS.append('-Winline')
    # ctx.env.CXXFLAGS.append('-fprofile-generate')


def debug(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-fstack-protector-all')
    ctx.env.CXXFLAGS.append('-fstack-protector-all')


def exceptions(ctx):
    configure(ctx)
    ctx.env.CFLAGS.remove('-fno-exceptions')
    ctx.env.CXXFLAGS.remove('-fno-exceptions')
    # ctx.check(header_name='libnoise/noise.h',
                # lib='noise',
               # use='libnoise',
               # includes=['/usr/include'],
               # fragment='#include <libnoise/noise.h>',
               # mandatory=True)

# dont use this. it was an attempt to use GCC flags to lint the C/C++ code
# just throws a shit ton of errors starting from the SDL libraries


def lint(ctx):
    configure(ctx)
    lint_flags = [
        '-ansi',
        '-fno-common',
        '-fshort-enums',
        '-pedantic',
        '-undef',
        '-W',
        '-Waggregate-return',
        '-Wall',
        '-Wcast-align',
        '-Wcast-qual',
        '-Wconversion',
        '-Wmissing-declarations',
        '-Wredundant-decls',
        '-Wmissing-prototypes',
        '-Wnested-externs',
        '-Wpointer-arith',
        '-Wshadow',
        '-Wstrict-prototypes',
        #'-Wtraditional',
        '-Wwrite-strings',
        '-Weffc++',
    ]
    ctx.env.CFLAGS += lint_flags
    ctx.env.CXXFLAGS += lint_flags


class prodtest_ctx(ConfigurationContext):
    cmd = 'prodtest'
    fun = 'prodtest'


def prodtest(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add + ['-Winline', '-DNOSTRIPSYMBOLS'],
              rm_flags=rm, production=True, use_clang=False)


class production_dbg_ctx(ConfigurationContext):
    cmd = 'production_dbg'
    fun = 'production_dbg'


def production_dbg(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add + ['-DNDEBUG', '-Winline'], optlevel=3,
              rm_flags=rm, production=True, use_clang=False)


class awesomium_ctx(ConfigurationContext):
    cmd = 'awe'
    fun = 'awe'


def awe(ctx):
    configure(ctx, awesomium=True)


class awesomium_dbg_ctx(ConfigurationContext):
    cmd = 'awedbg'
    fun = 'awedbg'


def awedbg(ctx):
    configure(ctx, awesomium=True, awesomium_debug=True)


class noawe_ctx(ConfigurationContext):
    cmd = 'noawe'
    fun = 'noawe'


def noawe(ctx):
    configure(ctx, awesomium=False, auth=False)


class auth_ctx(ConfigurationContext):
    cmd = 'auth'
    fun = 'auth'


def auth(ctx):
    configure(ctx, awesomium=True, auth=True)


class noassimp_ctx(ConfigurationContext):
    cmd = 'noass'
    fun = 'noass'


def noass(ctx):
    configure(ctx, assimp=False)


class clang_ctx(ConfigurationContext):
    cmd = 'clang'
    fun = 'clang'


def clang(ctx):
    configure(ctx, use_clang=True)


class gcc_ctx(ConfigurationContext):
    cmd = 'gcc'
    fun = 'gcc'


def gcc(ctx):
    configure(ctx, use_clang=False)


class address_sanitizer_ctx(ConfigurationContext):
    cmd = 'asan'
    fun = 'asan'


def asan(ctx, add=[], rm=[]):
    asan_path = os.environ.get('ASAN_PATH')
    if not asan_path:
        raise ValueError('ASAN_PATH not defined in your environment')
    flags = ['-fsanitize=address', '-fno-omit-frame-pointer', '-fno-common']
    link_flags = ['-fsanitize=address']
    os.environ['PATH'] = '{0}:{1}'.format(asan_path, os.environ['PATH'])
    configure(ctx, add_flags=add + flags, rm_flags=rm, link_flags=link_flags,
              optlevel=3, use_clang=True, awesomium=True)
