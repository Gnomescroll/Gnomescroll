APPNAME = 'gs_server'
VERSION = None

top = '.'
target = 'run'

import os
import platform
import shutil
import subprocess
import shlex
from waflib import Errors
from waflib import Tools

Tools.c_preproc.go_absolute = True

MAIN_TEST_CODE = '''
int main(int argc, char *argv[]) {
    return 0;
}
'''


def _grab_output(*cmd):
    return subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0]


def get_version():
    with open('../src/c_lib/common/version.h') as f:
        r = f.readlines()
        r = [line.strip() for line in r if 'GS_VERSION' in line]
        assert len(r) == 1
        r = r[0]
        pieces = r.split(' ')
        assert len(pieces) == 3
        version = int(pieces[-1])
        return version

VERSION = str(get_version())


def options(opt):
    opt.load('compiler_c compiler_cxx')


def check_clang(conf, use_clang=None):
    OS = platform.system()
    if OS != 'Linux':
        return False

    # use clang if requested or available
    # If you do check_tool('g++') after this, it won't compile, even though
    # the check works
    if use_clang is None:
        use_clang = bool(os.environ.get('WAF_USE_CLANG'))
    has_clang = False
    with open(os.devnull, 'w') as fnull:
        has_clang = (subprocess.call(shlex.split('which clang'), stdout=fnull,
                                     stderr=fnull) == 0)
    if use_clang and not has_clang:
        msg = 'ERROR: Clang requested, but not found on system'
        raise Errors.ConfigurationError(msg)
    return use_clang


def configure(conf, add_flags=[], rm_flags=[], link_flags=[], optlevel=0,
              production=False, use_clang=None):
    optflag = '-O' + str(optlevel)
    OS = platform.system()
    conf.env.os = OS

    arch = platform.architecture()[0]
    i386 = (arch == '32bit')
    x86_64 = (arch == '64bit')
    conf.env.i386 = i386
    conf.env.x86_64 = x86_64

    assert i386 != x86_64

    prodflag = '-DPRODUCTION='
    if production:
        prodflag += '1'
    else:
        prodflag += '0'

    use_clang = check_clang(conf, use_clang=use_clang)

    if use_clang:
        conf.check_tool('clang++')
    else:
        conf.check_tool('g++')

    cxxflags = []
    if OS == 'Windows':
        cxxflags += ['-g', '-fpermissive', '-static-libgcc', '-DNOMINMAX']
    else:
        cxxflags += ['-ggdb', '-fPIC']
        if i386:
            cxxflags.append('-m32')

    if OS == 'Darwin':
        cxxflags += ['-s']

    extra_options = [
        '-Wall',
        '-Wempty-body',
        '-DDC_SERVER=1',
        '-fno-exceptions',
        '-Wvla',  # warns variable array
        '-DGNOMESCROLL_DSO_EXPORTS=1',
        '-DGNOMESCROLL_DSO=1',
        '-Wparentheses',
        prodflag,
        optflag,
    ]

    if use_clang:
        extra_options.append('-ferror-limit=0')

    if production:
        extra_options.append('-Wno-inline')
    else:
        extra_options.append('-Winline')

    cxxflags += extra_options

    cxxflags += [c for c in add_flags if c not in cxxflags]
    cxxflags = [c for c in cxxflags if c not in rm_flags]

    conf.env.append_value('CFLAGS', cxxflags)
    conf.env.append_value('CXXFLAGS', cxxflags)
    conf.env.append_value('CPPFLAGS', cxxflags)

    #'-Wl', '--export-dynamic'  to export symbols from exe to shared libaries
    if OS == 'Windows':
        conf.env.append_value('LINKFLAGS', '-lmingw32')
        conf.env.append_value('LINKFLAGS', '-lwsock32')
        conf.env.append_value('LINKFLAGS', '-lws2_32')
        conf.env.append_value('LINKFLAGS', '-lwinmm')

    if OS == 'Linux':
        conf.env.append_value('LINKFLAGS', '-lrt')  # 64 bit support
        conf.env.append_value('LINKFLAGS', '-lpthread')  # threaded
    if OS != 'Windows':
        conf.env.append_value('LINKFLAGS', '-rdynamic')  # 64 bit support

    if OS == 'Darwin':
        # 64 bit lua shit
        conf.env.append_value(
            'CXXFLAGS', '-Xlinker -pagezero_size -Xlinker 10000')
        conf.env.append_value(
            'CXXFLAGS', '-Xlinker -image_base -Xlinker 100000000')

    if i386:
        link_flags.append('-m32')

    conf.env.append_value('LINKFLAGS', ' '.join(link_flags))

    if OS == 'Windows':
        libpath = os.path.abspath('../lib/win32')

    if OS == 'Windows':
        lua_inc_path = os.path.join(libpath, 'LuaJIT-2.0.0-beta10')
        lua_lib_path = [os.path.join(libpath, 'lib')]
    else:
        lua_lib_path = ['/usr/local/lib', '/usr/local/lib32']
        lua_inc_path = ['/usr/include/luajit-2.0',
                        '/usr/local/include/luajit-2.0']

        redis_lib_path = ['../lib/server/hiredis/lib32/',
                          '../lib/server/hiredis/lib64/']
        redis_inc_path = '../lib/server/hiredis/include/'

        libev_lib_path = ['/usr/lib'] + redis_lib_path
        libev_inc_path = ['/usr/include', redis_inc_path]

        libuuid_lib_path = ['/usr/lib']
        libuuid_inc_path = ['/usr/include']

    if OS == 'Windows':
        conf.check(header_name='lua.hpp',
                   lib='lua51',
                   use='lua51',
                   libpath=lua_lib_path,
                   includes=lua_inc_path,
                   uselib_store='LUA',
                   fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
                   mandatory=True,
                   env=env)
    else:
        conf.check(header_name='lua.h',
                   lib='luajit-5.1',
                   use='luajit-5.1',
                   uselib_store='LUA',
                   fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
                   libpath=lua_lib_path,
                   includes=lua_inc_path,
                   mandatory=True)

        # is already included in the lib/lin32/ folder
        conf.check(header_name='hiredis.h',
                   lib='hiredis',
                   use='hiredis',
                   uselib_store='REDIS',
                   fragment='#include <hiredis/hiredis.h>' + MAIN_TEST_CODE,
                   libpath=map(os.path.abspath, redis_lib_path),
                   includes=os.path.abspath(redis_inc_path),
                   mandatory=True)

        # sudo apt-get install libev-dev
        conf.check(header_name='ev.h',
                   lib=['ev', 'hiredis'],
                   use='ev',
                   uselib_store='EV',
                   fragment='#include <hiredis/adapters/libev.h>' +
                       MAIN_TEST_CODE,
                   libpath=map(os.path.abspath, libev_lib_path),
                   includes=map(os.path.abspath, libev_inc_path),
                   mandatory=True)

        # sudo apt-get install uuid-dev
        conf.check(header_name='uuid.h',
                   lib=['uuid'],
                   use='uuid',
                   uselib_store='UUID',
                   fragment='#include <uuid/uuid.h>' + MAIN_TEST_CODE,
                   libpath=map(os.path.abspath, libuuid_lib_path),
                   includes=map(os.path.abspath, libuuid_inc_path),
                   mandatory=True)

    conf.env.build_modules = False
    conf.env.INCLUDES = ['../src/c_lib', '../src/net_lib', '../src',
                         '/usr/local/include', '/usr/include']
    conf.env.RPATH = ['.', '..', '$ORIGIN/../lib', '/lib', '/usr/lib',
                      '/usr/local/lib']
    if OS == 'Linux':
        conf.env.INCLUDES.append('../lib/server/hiredis/include')
        conf.env.RPATH.append('$ORIGIN/../lib/server/hiredis/lib32')
        conf.env.RPATH.append('$ORIGIN/../lib/server/hiredis/lib64')


def build(bld):
    if bld.env.build_modules:
        bld.build_modules()
        return

    OS = platform.system()
    if OS != 'Windows':
        time_lib = ['rt']
    else:
        time_lib = []
    if OS == 'Darwin':
        time_lib = []

    use = time_lib + ['LUA']
    if OS == 'Linux':
        use += ['REDIS', 'EV', 'UUID']

    target = 'run'
    bld(features='cxx cxxprogram',
        source=['../src/server/_server.cpp', ],
        use=use,
        lib=time_lib,
        target=target)

    bld.add_post_fun(install_bin(target, 'build', '.'))


def build_modules(bld):
    pass


def install_bin(target, srcdir, outdir, dest_target=None):
    OS = platform.system()
    if dest_target is None:
        dest_target = target
    if OS == 'Windows':
        target += '.exe'
        dest_target += '.exe'

    def _install_bin(ctx):
        if not os.path.exists(outdir):
            os.makedirs(outdir)
        try:
            src = os.path.join(srcdir, target)
            dest = os.path.join(outdir, dest_target)
            if (os.path.exists(src) and
                    os.path.abspath(src) != os.path.abspath(dest)):
                shutil.copy2(src, dest)
                print 'Copied {0} to {1}'.format(src, dest)
        except Exception as e:
            msg = 'Failed to copy {0} to {1}. Reason: {2}'
            print msg.format(src, dest, str(e))

        try:
            # copy dlls into directory,
            # so Cell can run the exe from the folder.
            if OS == 'Windows':
                dll_path = '../lib/win32/dll/'
                dlls = os.listdir(dll_path)
                dlls = [dll for dll in dlls if dll.endswith('dll')]
                for dll in dlls:
                    src_dll = os.path.join(dll_path, dll)
                    dst_dll = os.path.join('./', dll)
                    shutil.copy2(src_dll, dst_dll)
                print 'Copied dlls to current directory'
        except Exception as e:
            msg = ('Error copying dlls from {0} to current directory. '
                   'Reason: {1}')
            print msg.format(dll_path, str(e))

    return _install_bin


from waflib.Build import BuildContext


BuildContext.build_modules = build_modules

'''
Subclass related *Context
e.g. ConfigurationContext, BuildContext
cmd,fun = 'name_of_function'
'''
from waflib.Configure import ConfigurationContext


class build_modules_ctx(ConfigurationContext):
    cmd = 'modules'
    fun = 'modules'


class optimized_ctx(ConfigurationContext):
    cmd = 'optimized'
    fun = 'optimized'


class debug_ctx(ConfigurationContext):
    cmd = 'debug'
    fun = 'debug'


class map_gen_ctx(ConfigurationContext):
    cmd = 'map_gen'
    fun = 'map_gen'


class linux_production_ctx(ConfigurationContext):
    cmd = 'linux'
    fun = 'linux'


class linux64_production_ctx(ConfigurationContext):
    cmd = 'linux64'
    fun = 'linux64'


class multicore_ctx(ConfigurationContext):
    cmd = 'multicore'
    fun = 'multicore'


class extra_ctx(ConfigurationContext):
    cmd = 'extra'
    fun = 'extra'


class profile_ctx(ConfigurationContext):
    cmd = 'profile'
    fun = 'profile'


def modules(ctx):
    configure(ctx)
    ctx.env.build_modules = True


def profile(ctx):
    configure(ctx, optlevel=3)
    ctx.env.CFLAGS.append('-pg')
    ctx.env.CXXFLAGS.append('-pg')
    ctx.env.append_value('LINKFLAGS', '-pg')


def extra(ctx):
    configure(ctx, add_flags=['-Wextra'])


def linux(ctx):
    production(ctx, add=['-shared-libgcc'])


def linux64(ctx):
    production(ctx, add=['-m64', '-shared-libgcc'])


def optimized(ctx):
    configure(ctx, optlevel=3)


def multicore(ctx):
    configure(ctx)
    optimized(ctx)
    ctx.env.CFLAGS.append('-j 6')
    ctx.env.CXXFLAGS.append('-j 6')


def debug(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-fstack-protector-all')
    ctx.env.CXXFLAGS.append('-fstack-protector-all')


def map_gen(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-DDUNGEON=1')
    ctx.env.CXXFLAGS.append('-DDUNGEON=1')


class production_ctx(ConfigurationContext):
    cmd = 'production'
    fun = 'production'


def production(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add + ['-DNDEBUG', '-Winline'], optlevel=3,
              rm_flags=rm, production=True, use_clang=False)


class production_dbg_ctx(ConfigurationContext):
    cmd = 'production_dbg'
    fun = 'production_dbg'


def production_dbg(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add + ['-DNDEBUG', '-Winline'], optlevel=3,
              rm_flags=rm, production=True, use_clang=False)


class prodtest_ctx(ConfigurationContext):
    cmd = 'prodtest'
    fun = 'prodtest'


def prodtest(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add + ['-Winline'], rm_flags=rm,
              production=True, use_clang=False)


class clang_ctx(ConfigurationContext):
    cmd = 'clang'
    fun = 'clang'


def clang(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add, rm_flags=rm, use_clang=True)


class gcc_ctx(ConfigurationContext):
    cmd = 'gcc'
    fun = 'gcc'


def gcc(ctx):
    configure(ctx, use_clang=False)


class address_sanitizer_ctx(ConfigurationContext):
    cmd = 'asan'
    fun = 'asan'


def asan(ctx, add=[], rm=[]):
    asan_path = os.environ.get('ASAN_PATH')
    if not asan_path:
        raise ValueError('ASAN_PATH not defined in your environment')
    flags = ['-fsanitize=address', '-fno-omit-frame-pointer', '-fno-common']
    link_flags = ['-fsanitize=address']
    os.environ['PATH'] = '{0}:{1}'.format(asan_path, os.environ['PATH'])
    configure(ctx, add_flags=add + flags, rm_flags=rm, link_flags=link_flags,
              optlevel=3)
