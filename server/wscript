APPNAME = 'gs_server'
VERSION = None

top = '.'
target = 'run'

import errno
import os
import platform
import shutil
import subprocess
import shlex

from waflib import Tools, Errors
Tools.c_preproc.go_absolute = True

OS = None

MAIN_TEST_CODE = """
int main(int argc, char *argv[]) {
    return 0;
}
"""


def _grab_output(*cmd):
    return subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0]

def get_version():
    with open('../src/c_lib/common/version.h') as f:
        r = f.readlines()
        r = [line.strip() for line in r if 'GS_VERSION' in line]
        assert len(r) == 1
        r = r[0]
        pieces = r.split(' ')
        assert len(pieces) == 3
        version = int(pieces[-1])
        return version

VERSION = str(get_version())

def options(opt):
    opt.load('compiler_c compiler_cxx')

def check_clang(conf):
    if OS != 'Linux':
        return False
        
    # use clang if requested or available
    # If you do check_tool('g++') after this, it won't compile, even though the check works
    use_clang = bool(os.environ.get('WAF_USE_CLANG'))
    has_clang = False
    with open(os.devnull, "w") as fnull:
        has_clang = (subprocess.call(shlex.split('which clang'), stdout=fnull, stderr=fnull) == 0)
    if use_clang and not has_clang:
        raise Errors.ConfigurationError('ERROR: Clang requested, but not found on system')
    if use_clang:
        conf.env['CC'] = ['clang']
        conf.env['CXX'] = ['clang']
    return use_clang

def configure(conf, add_flags=[], rm_flags=[], optlevel=0, production=False, use_clang=True):
    optflag = '-O' + str(optlevel)

    global OS
    OS = platform.system()
    conf.env.os = OS

    prodflag = '-DPRODUCTION='
    if production:
        prodflag += '1'
    else:
        prodflag += '0'

    #conf.check_tool('gcc')
    conf.check_tool('g++')

    # use clang if requested or available
    # If you do check_tool('g++') after this, it won't compile, even though the check works
    if use_clang:
        use_clang = check_clang(conf)

    #from waflib.Tools.compiler_c import c_compiler
    #c_compiler['linux'] = ['clang', 'gcc']
    #conf.load('compiler_c compiler_cxx')

    #conf.cc_add_flags()     #"-g"
    #conf.link_add_flags()   #"-g"

    cxxflags = []
    if OS == 'Windows':
        cxxflags += ['-g', '-fpermissive', '-static-libgcc']
    else:
        cxxflags += ['-ggdb','-fPIC']

    if OS == 'Darwin':
        cxxflags += ['-s']

    extra_options = [
        '-Wall',
        '-Wempty-body',
        '-DDC_SERVER=1',
        '-fno-exceptions',
        '-Wvla', #warns variable array
        '-DGNOMESCROLL_DSO_EXPORTS=1',
        '-DGNOMESCROLL_DSO=1',
        prodflag,
        optflag,
    ]

    if use_clang:
        extra_options.append('-ferror-limit=0')

    if production:
        extra_options.append('-Wno-inline')
    else:
        extra_options.append('-Winline')

    cxxflags += extra_options

    cxxflags += [c for c in add_flags if c not in cxxflags]
    cxxflags = [c for c in cxxflags if c not in rm_flags]

    conf.env.append_value('CXXFLAGS', cxxflags)

    #conf.env.append_value("LINKFLAGS", "-lz") ??

    #    #'-Wl', '--export-dynamic'  to export symbols from exe to shared libaries
    if OS == 'Windows':
        conf.env.append_value("LINKFLAGS", "-lmingw32")
        conf.env.append_value("LINKFLAGS", "-lwsock32")
        conf.env.append_value("LINKFLAGS", "-lws2_32")
        conf.env.append_value("LINKFLAGS", "-lwinmm")
        conf.env.append_value("CXXFLAGS", "-DNOMINMAX")

    if OS == 'Linux':
        conf.env.append_value("LINKFLAGS", "-lrt") #64 bit support
        conf.env.append_value("LINKFLAGS", "-lpthread") #threaded
    if OS != 'Windows':
        conf.env.append_value("LINKFLAGS", "-rdynamic") #64 bit support

    if OS == 'Darwin':
        # 64 bit lua shit
        conf.env.append_value("CXXFLAGS", "-Xlinker -pagezero_size -Xlinker 10000")
        conf.env.append_value("CXXFLAGS", "-Xlinker -image_base -Xlinker 100000000")

    if OS == 'Windows':
        libpath = os.path.abspath('../lib/win32')

    
    if OS == 'Windows':
        lua_inc_path = os.path.join(libpath, 'LuaJIT-2.0.0-beta10')
        lua_lib_path = [os.path.join(libpath, 'lib')]
    else:
        lua_lib_path = ['/usr/local/lib']
        lua_inc_path = '/usr/include/luajit-2.0'
        
        redis_lib_path = ['../lib/server/hiredis/lib32/', '../lib/server/hiredis/lib64/']
        redis_inc_path = '../lib/server/hiredis/include/'

        libev_lib_path = ['/usr/lib'] + redis_lib_path
        libev_inc_path = ['/usr/include', redis_inc_path]

        libuuid_lib_path = ['/usr/lib']
        libuuid_inc_path = ['/usr/include']        

    if OS == 'Windows':
        conf.check(header_name='lua.hpp',
                   lib='lua51', #'lua5.1',
                   use='lua51', #'lua5.1',
                   libpath=lua_lib_path,
                   includes=lua_inc_path,
                   uselib_store='LUA',
                   fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
                   mandatory=True)
    else:
        conf.check(header_name='lua.h',
               lib='luajit-5.1', #'lua5.1',
               use='luajit-5.1', #'lua5.1',
               uselib_store='LUA',
               fragment='#include <lua.hpp>' + MAIN_TEST_CODE,
               libpath=lua_lib_path,
               includes=lua_inc_path,
               mandatory=True)
               
        # is already included in the lib/lin32/ folder
        conf.check(header_name='hiredis.h',
            lib='hiredis',
            use='hiredis',
            uselib_store='REDIS',
            fragment='#include <hiredis/hiredis.h>' + MAIN_TEST_CODE,
            libpath=map(os.path.abspath, redis_lib_path),
            includes=os.path.abspath(redis_inc_path),
            mandatory=True)

        # sudo apt-get install libev-dev
        conf.check(header_name='ev.h',
            lib=['ev', 'hiredis'],
            use='ev',
            uselib_store='EV',
            fragment='#include <hiredis/adapters/libev.h>' + MAIN_TEST_CODE,
            libpath=map(os.path.abspath, libev_lib_path),
            includes=map(os.path.abspath, libev_inc_path),
            mandatory=True)

        # sudo apt-get install uuid-dev
        conf.check(header_name='uuid.h',
            lib=['uuid'],
            use='uuid',
            uselib_store='UUID',
            fragment='#include <uuid/uuid.h>' + MAIN_TEST_CODE,
            libpath=map(os.path.abspath, libuuid_lib_path),
            includes=map(os.path.abspath, libuuid_inc_path),
            mandatory=True)
            

    #conf.check(header_name="noise/noise.h",
                #lib="noise",
                #use="noise",
                #mandatory=True)

    conf.env.INCLUDES = ['../src/c_lib', '../src/net_lib', '../src','/usr/local/include', '/usr/include']
    conf.env.RPATH = ['.','..', '$ORIGIN/../lib', '/lib', '/usr/lib', '/usr/local/lib']
    if OS == 'Linux':
        conf.env.INCLUDES.append('../lib/server/hiredis/include')
        conf.env.RPATH.append('$ORIGIN/../lib/server/hiredis/lib32')
        conf.env.RPATH.append('$ORIGIN/../lib/server/hiredis/lib64')

def build(bld):
    OS = platform.system()
    if OS != 'Windows':
        time_lib = ['rt']
    else:
        time_lib = []
    if OS == "Darwin":
        time_lib = []

    use = time_lib+['LUA']
    if OS == 'Linux':
        use += ['REDIS', 'EV', 'UUID']

    ##attemping C++ build
    bld.env.CXXFLAGS.append('-fvisibility=hidden')    #hide most dso symbols for libc_lib
    bld(
        features = 'cxx cxxprogram',
        source = ['../src/server/_server.cpp',],
        use = use,
        lib = time_lib,
        target = 'run'
    )
    bld.env.CXXFLAGS.remove('-fvisibility=hidden')

    bld.add_post_fun(install_bin)


def install_bin(ctx):
    OS = platform.system()

    out = ''
    if OS == "Windows":
        out = 'build'

    if OS == "Linux":
        out = 'build'

    dests = []
    if OS == "Windows":
        dests = ['run.exe']
    else:
        dests = ['run']
    if OS == "Linux":
        dests.append('gnomescroll_server')
        
    run_target = 'run'
    if OS == 'Windows':
        run_target = 'run.exe'
        
    for run_dest in dests:
        try:
            src = os.path.join(out, run_target)
            dest = os.path.join('./', run_dest)
            if os.path.abspath(src) == os.path.abspath(dest):
                continue
            if os.path.exists(src):
                shutil.copy2(src, dest)
                print "Copied %s to %s" % (src, dest,)
        except Exception, e:
            print "Failed to copy %s to %s. Reason: %s" % (src, dest, e,)
        
    try:
        if OS == 'Windows': # copy dlls into directory, so Cell can run the exe from the folder.
            dll_path = '../lib/win32/dll/'
            dlls = os.listdir(dll_path)
            dlls = [dll for dll in dlls if dll.endswith('dll')]
            for dll in dlls:
                src_dll = os.path.join(dll_path, dll)
                dst_dll = os.path.join('./', dll)
                shutil.copy2(src_dll, dst_dll)
            print "Copied dlls to current directory"
    except Exception, e:
        print "Error copying dlls from %s to current directory. Reason: %s" % (dll_path, e,)
        
#def ensure_dir(path):
    #try:
        #os.makedirs(path)
    #except OSError, e:
        #if e.errno != errno.EEXIST:
            #raise


'''
Subclass related *Context
e.g. ConfigurationContext, BuildContext
cmd,fun = 'name_of_function'
'''
from waflib.Configure import ConfigurationContext

class optimized_ctx(ConfigurationContext):
    cmd = 'optimized'
    fun = 'optimized'

class optimized_ctx(ConfigurationContext):
    cmd = 'debug'
    fun = 'debug'

class map_gen_ctx(ConfigurationContext):
    cmd = 'map_gen'
    fun = 'map_gen'

class linux_production_ctx(ConfigurationContext):
    cmd = 'linux'
    fun = 'linux'
    
class linux64_production_ctx(ConfigurationContext):
    cmd = 'linux64'
    fun = 'linux64'

class multicore_ctx(ConfigurationContext):
    cmd = 'multicore'
    fun = 'multicore'

class extra_ctx(ConfigurationContext):
    cmd = 'extra'
    fun = 'extra'

class profile_ctx(ConfigurationContext):
    cmd = 'profile'
    fun = 'profile'
    
def profile(ctx):
    configure(ctx, optlevel=3)
    ctx.env.CFLAGS.append('-pg')
    ctx.env.CXXFLAGS.append('-pg')
    ctx.env.append_value("LINKFLAGS", "-pg")

def extra(ctx):
    configure(ctx, add_flags=['-Wextra'])

def linux(ctx):
    production(ctx, add=['-shared-libgcc'])
    
def linux64(ctx):
    production(ctx, add=['-m64', '-shared-libgcc'])
    
def optimized(ctx):
    configure(ctx, optlevel=3)

def multicore(ctx):
    configure(ctx)
    optimized(ctx)
    ctx.env.CFLAGS.append('-j 6')
    ctx.env.CXXFLAGS.append('-j 6')

def debug(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-fstack-protector-all')
    ctx.env.CXXFLAGS.append('-fstack-protector-all')

def map_gen(ctx):
    configure(ctx)
    ctx.env.CFLAGS.append('-DDUNGEON=1')
    ctx.env.CXXFLAGS.append('-DDUNGEON=1')

class production_ctx(ConfigurationContext):
    cmd = 'production'
    fun = 'production'

def production(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add+['-DNDEBUG', '-Winline'], optlevel=3, rm_flags=rm, production=True, use_clang=False)
    
class production_dbg_ctx(ConfigurationContext):
    cmd = 'production_dbg'
    fun = 'production_dbg'

def production_dbg(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add+['-DNDEBUG', '-Winline'], optlevel=3, rm_flags=rm, production=True, use_clang=False)
    
class prodtest_ctx(ConfigurationContext):
    cmd = 'prodtest'
    fun = 'prodtest'

def prodtest(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add+['-Winline'], rm_flags=rm, production=True, use_clang=False)

class clang_ctx(ConfigurationContext):
    cmd = 'clang'
    fun = 'clang'

def clang(ctx, add=[], rm=[]):
    configure(ctx, add_flags=add, rm_flags=rm, use_clang=True)

class gcc_ctx(ConfigurationContext):
    cmd = 'gcc'
    fun = 'gcc'

def gcc(ctx):
    configure(ctx, use_clang=False)
