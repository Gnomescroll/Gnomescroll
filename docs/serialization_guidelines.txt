All formats should be extendable and have defaults for missing values

Things to serialize:

Player:
    position
    inventory
        list of item ids
        
Item:
    list of item attributes
    location data

Map:
    Block data, dumped from the struct
    list of mechs

Chests:
    list of item ids
    

Everything will use string names
For renaming, we must maintain functions in the codebase that define a renaming scheme

For the map, we need to dump a palette file, that maps names to ids
We need the same internal renaming functions for the palette file


For backups,
    save backups for the past N days (3?), and for the past few hours
    The backups should be stored as a gzip'd bundle
    we rsync these to our machines regularly


Files -- Folder:
map -- map
mech -- map
containers -- container
players -- players
items -- items

Load order:
map, mech
items
containers
players

BACKUPS -- os level

redis authorization

-- what about if we change the dimensions of a container? do i really need to version everything?
    -- version all container metadata. store version ids on item ugh
    -- when loading items, wait for all to arrive (we can get them in one batch?). then, make sure they all fit in xy bounds
    -- if they don't fit in xy bounds, log it (could be an error)
    -- and sort them by slot, and put them back.
    -- if for some reason the container has SHRUNK, keep those items around, but log it


TODO
magic "lost items" container for hand item if present; later, this is how player will get purchased items
    -- the game assumes nothing in hand when container not opening.
    -- loading straight into hand breaks this assumption

For error detection,
Bubble up any errors to the redis callback.
Then, set an error flag on player load data struct
We can leave in the asserts, unless they are a problem
Use a giant enum for errors and their messages
Log all errors with the bad data to disk
Maybe even the parse data structs, but at least the input data
Containers inserts from load need to check error

renaming scheme for item and container names

player information: color, spawn points

spawners and bases must be serialized too, similar to mechs

TODO -- spawners need global ids. luckily these are private to the server so its not a problem
UGH -- any server-specific data, even per player, should be on the server
--server specific player data is another issue entirely
--for server-specific-player-data, we'll dump it all in one file. we'll need to build a manager for the player data, but
--it is not too much data to record a few small things about everyone we've seen. if it ever grows too large, we can
--delete information thats more than a few months old

make sure saving current player data occurs on exit, need to wait for all replies from redis...


TODO
    Error handling + logging
    Save containers
    Save mechs
    Item and container renaming schemes
        -- name changes
        -- item removals
    Serialize everything when told to teardown
    "Lost items" container, and load any hand item into it

Container saving:
    -- Need to cache block containers' world positions, because its too messy querying back to the map for the save.
    -- Or we make that part of the memcpy, but i'd rather just memcpy the whole list
    -- chunk index is already cached. its not unreasonable to cache position also
    need a separator line between each container. "-" is fine
    can add a header for the entire file also, with number of containers, version saved etc

=====
DOCS:

Item UUIDs are a typical UUID, generated by libuuid's uuid_generate()
Item UUIDs are generated when first inserted into a container.
UUIDs' only role is to check for item dupes.

All player related data is stored in redis. Each player has 5 keys:
player:<user_id>
player:hand:<user_id>
player:toolbelt:<user_id>
player:inventory:<user_id>
player:synthesizer:<user_id>
player:energy_tanks:<user_id>

The player's main key, player:<user_id>, stores player metadata that is not server specific.
Currently, this is only the player's chosen color

The player metadata serialization format is:
    TODO

The player:<container_name>:<user_id> keys are a newline delimited list of item lines, with a single header for the player container metadata
    PLAYER_CONTAINER_HEADER
    ITEM1
    ITEM2
    ITEM3

The player container header serialization format is:
    TODO

The item serialization format is:
    TODO
    
Block containers are stored on local disk per-server. It is a single file. It is read once,
at server startup. It is written periodically with the map save.
The container file format consists of a global header, and + delimited blocks of container data
    CONTAINER_FILE_HEADER
    CONTAINER_HEADER1
    ITEM1
    ITEM2
    ITEM3
    +
    CONTAINER_HEADER2
    ITEM4
    ITEM5
    ITEM6
    +

The item serialization format is the same for block containers and player containers;

The block container header serialization format is:
    TODO


Item and container names are mapped through a renaming scheme to ensure forward compatibility.
Ideally, they are never renamed. If any item or container is renamed, it must be added to the renamer.
Don't change any item name without good reason.


Error handling policy:

Deserialization:
    For data that is loaded only at runtime (server-specific data):
    Log error, set global error flag, but continue deserializing
    At the end of deserialization, if error flag is true, abort program.
    Admin must correct problems with the data to continue.

    For player-specific data, loaded when user joins:
    Log error, and disconnect player with error message.
    Admin must correct problems with the player's data.

Serialization:
    Any invalid data is not written. However, a single invalid container does not prevent all containers from being written.
    Any data is logged to a related error file, and actual serialization is aborted.
    Hopefully the data can be recovered later in this case.
    Note that the data is most likely not corrupt, but that conditions outside of the program cause failure.
    Network failure, player item server failure are examples.
    If any error is recoverable, it will recover from it. For example, UUIDs should be set before serialization,
    but if they aren't for some reason, a UUID will be generated at that time.


Loading procedure:
    Load map. If no map found, generate one.
        -- Copy all other save files elsewhere!
        -- We should be versioning per distinct map generation, not per GS_VERSION
    Load containers
    Load mechs/fabs
    Load player metadata

Loading items:
tmp item list for player item loading, so we can safely abort the transaction

Not only do the container names need to be forward compatible, but their associated block ids must be also
TODO -- block name palette
mechs also need a palette, or string serialization

Versioning should be done per map-gen, not by the build version. Still, tag the map-gen version with the build version number

NAME MANAGEMENT:
for each dat, save all names to two files: active and inactive
a new name can be added to active
an active name can only be moved to inactive
no names can be removed from inactive

when starting up, check these conditions
// load code definitions
// read the file to temp struct
// compare
// if bad, warn and abort
// else, save new files

--in the config verifiers, check that all replacement names map to an active name
    
MORE RULES:
Don't decrease the size of any container.
Don't change item names arbitrarily, but if you do add it to the renaming scheme.
If you remove any item, add its replacement to the renaming scheme.
This means, don't remove an item without providing a replacement.

==========
REMAINING:
==========
logging of more specific data to help find problems
    -- some log filename(s)
    -- some functions for writing certain data + message to it. will help find the problem quickly

map versioning
    -- when a map is generated, we're on a new version. all the files have to be updated. we can use a timestamp for it
    DONE

saving everything on proper teardown
    -- need some flags for the async player saves. need to shut down the network traffic, but keep the state around
    DONE

saving things periodically
    -- fuccccck. the sliding time window for map saving WILL introduce errors in the item/container save files, at some point
    -- we can keep a 2nd map open but brandon will freak out
    -- brandon's chunk versioning
    DONE

subprogram in the server that gets all of the player redis data and checks its validity
    -- this can wait

Startup:
    Read old palettes
    Load data
    Apply palette transforms
    Resave palettes
    Resave data         -- check, but i think this is the last thing to do. also don't rename the palettes/data files from tmp until ALL are complete
    Then, we can begin
    DONE

each map gen will cause a new "save" version to be created
all save files for this version will go in folder named
world-<dc_version>-<timestamp>
and placed in the main world/ folder

inside the versioned world folder, we will have the same folder structure we have now in the main world folder

when saving all data, we will create a tmp versioned world folder
all save files will go in here. they do not need the .tmp extension

when all the saving is confirmed completed, we will rename the old versioned world folder to .bak,
then rename the .tmp folder to normal

if any of it fails in the startup fails, abort the program.

if it fails during the continuous save, continue as normal, just dont rename the folder

==========
REALLY REMAINING

Logging errors with details

Backup cron jobs
    -- gzip, copy out to other folder
    -- run the gzip backup right before we initiating saving
