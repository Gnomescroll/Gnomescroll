====================


Object
------------

--Holds components dynamically
--Get components from component pools
--This is *the* object. Should not inherit or be inherited from.

typedef enum
{
    OBJECT_REFILL,
    OBJECT_BLOCK_DROP,
} ObjectType;

class Object
{
    private:
        Components** components;
    public:
        int id;
        ObjectType type;
        
        // returns component of type if available
        // must cast to desired component manually
        void* get_component(ComponentType type);
        void* get_component_interface(ComponentInterfaceType type);
};

If we would like to take an existing class and interface with this system,
we can attach Object as a member.  This is a simple way to experiment with
a component in an otherwise incompatible system, with little
coding overhead.

<<<<<<<<<<<

class OldThing
{
    public:
        // specific stuff
};

>>>>>>>>>>>

class OldThing
{
    public:
        // specific stuff

        Object object;
        // can now attach a component here
};

====================


Component
---------

--Specifies data and behaviour at some level of granularity
--Can be attached to Object
--Inherit ABC only when necessary
-- enum ComponentType per component (excluding ABCs)
-- enum ComponentInterfaceType per component interface (ABCs or standalone components)

typedef enum
{
    COMPONENT_POSITION,
    COMPONENT_POSITION_MOMENTUM,
    COMPONENT_STACKABLE,
    COMPONENT_SPRITE,
} ComponentType;

typedef enum
{
    COMPONENT_INTERFACE_PHYSICS,
    COMPONENT_INTERFACE_STACKABLE,
} ComponentInterfaceType;

------------------------------
No inheritance

class StackableComponent
{
    public:
        ComponentType type;
        int max;
        int size;
        
    bool merge_stack(StackableComponent* stack)
    {   // returns true if stack size changes
        int room = this->max - this->size;
        if (room <= 0) return false;
        int available = stack->size;
        if (available <= 0) return false;
        if (room < available) available = room;
        this->size += available;
        stack->size -= available;
        return true;
    }
        
    StackableComponent()
    : type(COMPONENT_STACKABLE), max(10), size(1)
    {}
};

------------------------------
Using ABC (Abstract base class)

class PhysicsComponent
{
    public:
        ComponentType type;
        Vec3 get_position() = 0;
        void set_position(Vec3 position) = 0;
        Vec3 get_momentum() = 0;
        void set_momentum(Vec3 momentum) = 0;
        
    
    ~PhysicsComponent() {}
};

ComponentType PhysicsComponent::type = COMPONENT_PHYSICS;

const Vec3 NULL_MOMENTUM = { 0,0,0 };

class PositionPhysicsComponent: public PhysicsComponent
{
    public:
        Vec3 position;
        
        Vec3 get_position() { return this->position; }
        void set_position(Vec3 position) { this->position = position; }
        Vec3 get_momentum() { return NULL_MOMENTUM; }
        void set_momentum(Vec3 momentum) {}
}

class PositionMomentumPhysicsComponent: public PhysicsComponent
{
    public:
        Vec3 position;
        Vec3 momentum;
        
        Vec3 get_position() { return this->position; }
        void set_position(Vec3 position) { this->position = position; }
        Vec3 get_momentum() { return this->momentum; }
        void set_momentum(Vec3 momentum) { this->momentum = momentum; }
}

=====================


Reusing Components without Object
---------------------------------

We can write a specialized class, if we want to use a Component
but not be a generic Object:

class SpriteObject
{
    public:
        int id;
        ObjectType type;
        SpriteComponent* sprite;
        
    SpriteObject()
    {
        this->sprite = Components::get(SPRITE_COMPONENT);
        this->sprite->index = DEFAULT_SPRITE_INDEX;
    }
};

The downside is that this object cannot be used where Object can be.
In some cases this does not matter, others you would need to duplicate
or templatize the Object method.

(I do not see the benefit to doing this, because the overhead for Object is the same)
=====================


Component Management
--------------------

We track Components in lists
Use a template for the list to avoid requiring a common base class for
all components

template <class Component, int SIZE>
class ComponentList
{
    protected:
        Component* pool;

    Component* register(ComponentType type)
    {
        // return pointer to available component
        // NULL if full
    }
    
    void unregister(Component* component)
    {
        // deallocate/release component in pool
    }
        
    void init()
    {
        this->pool = new pool[SIZE];
    }
    
    ComponentList<Component,SIZE>() : pool(NULL)
    {
        this->init();
    }
    
    ~ComponentList<Component,SIZE>()
    { 
        if (this->pool != NULL) delete this->pool;
    }
};

// track PositionPhysicsComponent
const int MAX_PHYSICS_COMPONENTS = 4096;
typedef ComponentList<PositionPhysicsComponent, MAX_PHYSICS_COMPONENTS>
    PositionPhysicsComponentList;

=====================


Communicating Between Components
--------------------------------

Example:
We are removing an InventoryItem from Inventory, and creating a pickup item in the world:

struct InventoryItem
{
    int item_id;
    ObjectType item_type;
    int stack_size;
};

void Inventory::remove_item_at_slot(int slot)
{
    // get data from inventory
    struct InventoryItem* item = &this->contents[slot];    
    if (item->item_id == EMPTY_SLOT) return; // the slot was empty
    
    // get our position so we can place new item in world
    Agent* owner = Agents::get(this->owner); // Inventory has an owner property.
                                             // For unowned inventory,
                                             // need alternate way to get location
    if (owner == NULL) return; // print an error here
    
    // create new world item
    Object* pickup_item = Objects::create(item->item_type);
    if (pickup_item == NULL) return; // could not create, dont remove
    
    // copy stackable data
    StackableComponent* stack = (StackableComponent*)pickup_item->get_component_interface(COMPONENT_INTERFACE_STACKABLE);
    if (stack != NULL) stack->size = item->size; // didnt need a common base to modify stack size
    
    // set physics
    PhysicsComponent* physics = (PhysicsComponent*)pickup_item->get_component_interface(COMPONENT_INTERFACE_PHYSICS);
    if (physics != NULL)
    {
        Vec3 position = owner->get_center();
        Vec3 forward = owner->forward();
        const float throwing_force = 2.0f; // get this value from a better place
        physics->set_position(position);
        physics->set_momentum(vec3_mult_scalar(forward, throwing_force));
    }
    else { /* why are we throwing an item without physics on the ground? */ }
        
    BornComponent* born = (BornComponent*)pickup_item->get_component_interface(COMPONENT_INTERFACE_BORN);
    if (born != NULL) pickup_item->born();    // always call this for newly created objects, after data has been set
        
    // reset item state
    item->item_id = EMPTY_SLOT;
    item->item_type = OBJECT_NONE;
    item->stack_size = 1;
}


=====================


Object creation internals
-------------------------

There will be a singleton object manager. System will not interface with
it directly. It will look like this:

const int MAX_OBJECT_TYPES = 256;
class ObjectList
{
    private:
        // keep a counters for individual object indices
        int* indices;
        int* maximums;
    public:
        int get_free_id(ObjectType type);
        void destroy(int id);
        void create(ObjectType type, int id);

        void set_object_max(ObjectType type, int max)
        {
            this->maximums[(int)type] = max;
        }
        
        void init()
        {
            this->indices = (int*)calloc(MAX_OBJECT_TYPES, sizeof(int));
            this->maximums = (int*)calloc(MAX_OBJECT_TYPES, sizeof(int));
        }
};

ObjectList* object_list;

void init_object_list()
{
    object_list = new ObjectList;
    
    // must specify maximum values for objects here
    object_list->set_object_max(OBJECT_HEALTH_REFILL, 256);
    object_list->set_object_max(OBJECT_STONE, 1024);
}

void destroyObject(Object* object)
{
    object_list->destroy(object->id);
}

each object type will have a single creation function
Object* createHealthRefill()
{
    ObjectType type = OBJECT_HEALTH_REFILL;
    int id = object_list->get_free_id(type);
    Object* obj = object_list->create(type, id);
    if (obj == NULL) return NULL;
    obj->add_component(COMPONENT_PICKUP);
    obj->add_component(COMPONENT_POSITION_MOMENTUM_PHYSICS);
    return obj;
}

and a ready function, called after creation and data loading (like setting position)

void readyHealthRefill(Object* refill)
{
    // set voxel stuff if it has voxels
}

and a die function, called right before removing the object from memory
void dieHealthRefill(Object* refill)
{
    // any necessary teardown
}

We also have one entry point which allows us to parameterize creation.
This is useful in random drop tables (anywhere we would need to switch(){} 
to call the correct creation method)

Object* Objects::create(ObjectType type)
{
    switch (type)
    {
        case OBJECT_HEALTH_REFILL:
            return createHealthRefill();
        
        default:
            printf("WARNING: creating unknown object type %d\n", type);
            return NULL;
    }
    return NULL;
}

there would be analogous switches for ready and die

Both would be defined, but it is a choice to expose the single creation functions
The create(type) one will probably be the only option

=====================

TODO:

How to deal with common controller methods?

Tick
--Is a component, but relies heavily on shared components
Update
--Is a component, but relies on shared components

Die?
Born?
--Use flat functions
--4 sets (in call order):
++Create
<fill data>
++Born/Ready
++Die
++Destroy

Do an example for integrating the network
-- Network components

Figure out a good folder hierarchy:

entity/
    objects.cpp -- holds outward api -- create/born/die/destroy(type)
    objects/
        object.cpp -- main object file
        one file per object type
            
    components.cpp  (component implementations)
    components/
        list.cpp     -- component  list tracker
        component.cpp   -- main component file
        
        pickup.cpp
        tick.cpp (well, probably tick/)
        stackable.cpp

    interfaces.cpp (component interfaces)
    interfaces/  (one file per component interface)
        interface.cpp -- main interface file
        pickup.cpp
        tick.cpp
        stackable.cpp 
    
    network.cpp (network packets/handlers)
    network/
        create.cpp
        physics.cpp
        stackable.cpp ?? since packets are heavily bundled, these dont make sense, unless i can chain packets or something


entity/
    object.cpp              -- exposed API
    object/
        main.cpp            -- list instantiation, underlying API methods
        object.cpp          -- Object class
        object_list.cpp     -- ObjectList class
        
    component.cpp           -- exposed API
    component/
        main.cpp            -- list instantiations, underlying API methods
        component.cpp       -- Component base class
        component_list.cpp  -- ComponentList template
    components/
        interfaces at base level
        physics/            -- concrete in here

    network/                -- packet stuff
    
        
Do we still need subtypes?
--Not really
--Saved time in implementing the switches
--This doesnt use switches, specify one set of born/die methods per objects and done

See how we would integrate the inventory into the system
--would work well on agents
--for attaching to cubes, we lack the concept of item-as-cube, but would be the same

=====================

References:
https://docs.google.com/present/view?id=0ATIohmzo6z7TZGhjbmhidnFfMTg1MWNkcTJmcWZ4&hl=en&pli=1#




==============

Implementing:

Object

Object CRUD interface
Object store

Component(s)

Base component (common metadata only)
Component list template
Component list interface

==============
